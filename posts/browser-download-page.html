<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="description" content="Explore how browsers download web pages through the TCP/IP stack. Learn about encapsulation, decapsulation, and how data moves from HTTP requests down to physical bits and back up to the browser." />
    <meta name="keywords" content="Portfolio, Engineer, Web, Browser, TCP/IP, HTTP, Networking, Protocol Stack, Encapsulation" />
    <meta property="og:url" content="https://mortemousque.com/posts/browser-download-page" />
    <meta property="og:description" content="Explore how browsers download web pages through the TCP/IP stack. Learn about encapsulation, decapsulation, and how data moves from HTTP requests down to physical bits and back up to the browser." />
    <meta property="og:title" content="Browser Downloading Web Pages - Aymeric Mortemousque" />
    <meta property="og:type" content="article" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/assets/style.css" />
    <link href="https://fonts.googleapis.com/css?family=Chivo:400,700|Playfair+Display:400,700&display=swap" rel="stylesheet" />
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/highlight.min.js"></script>
    <!-- Mermaid for diagrams rendered from ```mermaid code blocks -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>
      if (window.mermaid) {
        window.mermaid.initialize({ startOnLoad: true });
      }
    </script>
    <title>Browser Downloading Web Pages</title>
    <script type="module" src="/assets/scripts/components/index.js"></script>
  </head>

  <body class="post">
    <site-header variant="post-detail" title="Browser Downloading Web Pages" back-url="/posts"></site-header>
    <main>
      <p>When you type a URL and hit Enter, your browser kicks off a surprisingly complex journey across the network. Under the hood, your HTTP request is wrapped, sliced, addressed, and turned into raw bits that travel through the TCP/IP stack, cables, routers, and Wiâ€‘Fi. In this post, weâ€™ll walk through how a browser actually downloads a web page, from your address bar down to the wire and back up.</p>
<h2 class="title">From URL Input to Network Request</h2>
<p>When the user enters a URL, the browser process handles it on the UI<br>thread. It parses the text to decide what to do:</p>
<ul>
<li>If the input looks like a search term â†’ send it to the search engine.</li>
<li>If it looks like a valid URL â†’ forward it to the networking service (another process).</li>
</ul>
<p>The networking service starts the request using the TCP/IP stack.<br>A network connection commonly use 3 application layer protocol (DNS, TLS, HTTP), each relaying on TCP/IP stack.</p>
<p>in js we have a high level abasctraciton <code>fetch</code> API hiding the complexity. but under the hood there are multiple phase for a request.<br>but lets look at a lowev level python implementation:</p>
<pre><code class="language-py">import socket
import ssl

# --------------------------
# 1. CREATE SOCKET (no TCP yet)
# --------------------------
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# --------------------------
# 2. WRAP IN TLS (optional for HTTPS)
# --------------------------
context = ssl.create_default_context()
conn = context.wrap_socket(sock, server_hostname="example.com")

# --------------------------
# 3. CONNECT (DNS lookup + TCP handshake happens here)
# --------------------------
conn.connect(("example.com", 443))

# --------------------------
# 4. BUILD HTTP REQUEST BY HAND
# --------------------------
http_request = (
    "POST /api/items HTTP/1.1\r\n"
    "Host: example.com\r\n"
    "Content-Type: application/json\r\n"
    "Content-Length: 14\r\n"
    "\r\n"
    '{"name":"foo"}'
)

# --------------------------
# 5. SEND HTTP PAYLOAD (headers + body)
# --------------------------
conn.sendall(http_request.encode())

# --------------------------
# 6. RECEIVE HTTP RESPONSE
# --------------------------
response = conn.recv(4096)
print(response.decode())

conn.close()</code></pre><p>Now lets see each phase in depth</p>
<h2 class="title">Establishing the Connection: DNS, TCP, and TLS</h2>
<p>Before your browser can send the HTTP request, it needs to establish a connection to the server. This happens in three steps:</p>
<h3>1. DNS Lookup: From Domain to IP Address</h3>
<p>Your browser needs an IP address to connect, but you typed <code>https://example.com</code>, so the browser (or OS) queries DNS servers to resolve the domain name.</p>
<p>If we take the example earlier,  under the hood <code>conn.connect((&quot;example.com&quot;, 443))</code> triggers the OS to call <code>getaddrinfo()</code> internally, which performs DNS resolution.</p>
<p><strong>DNS Records:</strong></p>
<p>First, it&#39;s important to understand how DNS servers store and organize domain information. DNS uses different <strong>record types</strong> stored in <strong>zone files</strong> to map domain names to various resources. Each record type serves a specific purpose, whether it&#39;s pointing to an IP address, defining an alias, or specifying authoritative name servers.</p>
<p>Here is a simplified version of a zone file for example.com</p>
<pre><code class="language-text">DNS Zone File: example.com
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NAME                 â”‚ TTL  â”‚ TYPE  â”‚ DATA                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ example.com.         â”‚ 3600 â”‚ A     â”‚ 93.184.216.34                    â”‚
â”‚ example.com.         â”‚ 3600 â”‚ AAAA  â”‚ 2606:2800:220:1:248:1893:25c8... â”‚
â”‚ www.example.com.     â”‚ 3600 â”‚ CNAME â”‚ example.com.                     â”‚
â”‚ example.com.         â”‚ 3600 â”‚ NS    â”‚ ns1.example.com.                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><strong>How they work:</strong></p>
<ul>
<li><strong>A Record</strong>: Domain â†’ IPv4 address. Browser queries for an A record to get the server IP.</li>
<li><strong>AAAA Record</strong>: Domain â†’ IPv6 address. Same as A but for the newer IPv6 protocol.</li>
<li><strong>CNAME Record</strong>: Domain alias â†’ another domain. DNS follows the chain: <code>www.example.com</code> â†’ <code>example.com</code> â†’ <code>93.184.216.34</code></li>
<li><strong>NS Record</strong>: Tells which servers are authoritative for this domain (handle DNS queries for it).</li>
</ul>
<p><strong>DNS Resolution Flow:</strong></p>
<p>DNS resolution checks caches at every level (browser, OS, resolver). On cache miss, it follows a hierarchical lookup: browser â†’ local DNS resolver â†’ root server â†’ TLD server â†’ authoritative server.</p>
<pre class="mermaid">flowchart LR
    Browser["ğŸ–¥ï¸ Browser<br/>example.com<br/><i>(cache miss)</i>"]
    
    subgraph LocalDNS["Local DNS Resolver<br/>(ISP or 8.8.8.8)"]
        direction TB
        Resolver["DNS Resolver<br/>Recursive Lookup"]
    end
    
    subgraph DNSHierarchy["DNS Server Hierarchy"]
        direction TB
        Root["ğŸŒ Root Server<br/>(.)"]
        TLD["ğŸŒ TLD Server<br/>(.com)"]
        Auth["ğŸŒ Authoritative Server<br/>(example.com)"]
    end
    
    Browser -.->|"1. Query: example.com<br/>(after browser/OS cache miss)"| Resolver
    Resolver -->|"2. Where is .com?"| Root
    Root -->|"3. NS record for .com<br/>â†’ TLD server IP"| Resolver
    Resolver -->|"4. Where is example.com?"| TLD
    TLD -->|"5. NS record for example.com<br/>â†’ Auth server IP"| Resolver
    Resolver -->|"6. A record for example.com?"| Auth
    Auth -->|"7. A record: 93.184.216.34<br/>TTL: 3600s"| Resolver
    Resolver -->|"8. IP: 93.184.216.34<br/>(cached at all levels)"| Browser
    
    style LocalDNS fill:#fff4e1,stroke:#cc8800,stroke-width:2px
    style DNSHierarchy fill:#ffe1f5,stroke:#cc0066,stroke-width:2px
    style Browser fill:#b3d9ff,stroke:#0066cc
    style Resolver fill:#ffe6b3,stroke:#cc8800
    style Root fill:#ffb3d9,stroke:#cc0066
    style TLD fill:#ffcce6,stroke:#cc0066
    style Auth fill:#ffe6f5,stroke:#cc0066</pre><h3>2. TCP Handshake: Opening the Connection</h3>
<p>Now that we have the serverâ€™s IP address, the OS kernel opens a TCP connection by performing the 3-way handshake. Each step is a TCP segment whose header includes control-flag bits (such as SYN and ACK) that are set to 0 or 1.</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: TCP 3-Way Handshake (Connection Establishment)
    Client->>Server: SYN (seq=100)
    Server->>Client: SYN-ACK (seq=300, ack=101)
    Client->>Server: ACK (seq=101, ack=301)
    Note over Client,Server: Connection Established âœ“
</pre><ol>
<li><strong>SYN</strong>: Your machine sends a TCP segment with the SYN flag to the server&#39;s IP and port (e.g., port 443 for HTTPS)</li>
<li><strong>SYN-ACK</strong>: The server responds with SYN and ACK flags, acknowledging your request</li>
<li><strong>ACK</strong>: Your machine sends back an ACK to confirm the connection is open</li>
</ol>
<h3>3. TLS Negotiation: Securing the Connection</h3>
<p>The TLS is the protocol of encryption of HTTP*<strong>S</strong>. Encrypted data<br>For HTTPS, the browser and server must negotiate encryption <strong>before</strong> sending any HTTP data. This happens in the TLS handshake:</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: TLS Handshake (Establishing Encryption)
    Client->>Server: ClientHello<br/>(TLS versions, cipher suites, random)
    Server->>Client: ServerHello<br/>(chosen cipher, random)
    Server->>Client: Certificate<br/>(public key, signed by CA)
    Server->>Client: ServerHelloDone
    
    Note over Client: Verify certificate<br/>against trusted CAs
    
    Client->>Server: ClientKeyExchange<br/>(encrypted pre-master secret)
    Client->>Server: ChangeCipherSpec
    Client->>Server: Finished (encrypted)
    
    Note over Server: Derive session keys<br/>from randoms + pre-master
    
    Server->>Client: ChangeCipherSpec
    Server->>Client: Finished (encrypted)
    
    Note over Client,Server: Secure Connection Established âœ“<br/>All HTTP traffic now encrypted</pre><p><strong>Understanding the TLS Handshake:</strong></p>
<ol>
<li><p><strong>ClientHello</strong>: Browser announces supported TLS versions, cipher suites, and sends a random value</p>
</li>
<li><p><strong>ServerHello + Certificate</strong>: Server picks a TLS version and cipher suite, sends its certificate (with public key) and another random value</p>
</li>
<li><p><strong>Certificate Verification</strong>: Browser validates the server&#39;s certificate against trusted Certificate Authorities (CAs)</p>
</li>
<li><p><strong>Key Exchange</strong>: Client generates a pre-master secret, encrypts it with the server&#39;s public key, and sends it. Both sides derive shared session keys using the random values and pre-master secret</p>
</li>
<li><p><strong>Finished</strong>: Both sides send encrypted &quot;Finished&quot; messages to confirm the handshake succeeded and verify the keys work</p>
</li>
</ol>
<p>Now every HTTP message will be encrypted with the negotiated keys before being handed to TCP.</p>
<h2 class="title">TCP/IP Model Overview</h2>
<p>Web communication uses a stack of protocols. <strong>DNS and TLS are an application-layer protocol</strong> (like HTTP). Whatever the protocol, its messages still make a round trip â€œon the wireâ€ by being <strong>encapsulated</strong> inside the lower layers (TCP/UDP â†’ IP â†’ link â†’ physical). Each layer builds on top of the one below it, from your browser down to the physical wire.</p>
<p>HTTPS request (bytes carried inside one Ethernet frame):</p>
<pre><code class="language-text">â”‚ Ethernet Header â”‚ IPv4 Header â”‚ TCP Header â”‚ TLS Record Header â”‚ HTTP bytes â”‚ FCS 
â”‚     ~14 B       â”‚  20â€“60 B    â”‚  20â€“60 B   â”‚       5 B         â”‚ variable   â”‚ 4 B </code></pre><p>Each layer processes a stream of <strong>bytes</strong> and understands only <strong>its own header bytes</strong>. Everything after that header is the layerâ€™s <strong>payload</strong> (opaque bytes as far as that layer is concerned). The payload may <em>represent</em> structured data for the next layer up, but this layer doesnâ€™t need to interpret it.</p>
<p>The header exists so each layer can do its job: the sender sets it during <strong>encapsulation</strong>, and the receiver reads it during <strong>decapsulation</strong> to decide <strong>who should handle the payload next</strong>. Headers typically include:</p>
<ul>
<li><strong>Header size / boundaries</strong>: either a fixed header size (e.g., Ethernet without VLAN) or a field that says how long the header is (e.g., IPv4 IHL, TCP Data Offset), plus sometimes a <strong>total length</strong> (e.g., IPv4 Total Length) so you know where the packet ends.</li>
<li><strong>Encapsulated payload type (in this header)</strong>: a field in the current layerâ€™s header that tells what kind of payload is inside, so the receiver can pick the right parser (e.g., Ethernet <strong>EtherType</strong> â†’ IPv4/IPv6, IPv4 <strong>Protocol</strong> / IPv6 <strong>Next Header</strong> â†’ TCP/UDP/ICMP).</li>
<li><strong>Routing / delivery addresses</strong>: the bytes used for forwarding and demultiplexing (MAC for the local hop, IP for end-to-end routing, ports for delivery to a process).</li>
<li><strong>Error detection</strong>: many layers include an integrity check over â€œthe part they care aboutâ€ (often header + some/all payload). The receiver recomputes the check and compares it to the transmitted value; if it doesnâ€™t match, the unit is typically dropped.</li>
</ul>
<h2 class="title">Encapsulation in detail</h2>
<p>Let&#39;s look deeper how our HTTP data makes it through the wire.</p>
<hr>
<h3>ğŸ”µ 1. Application Layer: HTTP Message</h3>
<p>The browser builds an HTTP request as plain text. For <code>https://example.com/page.html</code>, it creates:</p>
<pre><code class="language-http">GET /page.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml...
Connection: keep-alive
</code></pre><p>The browser then calls a <strong>system call</strong> (like <code>write()</code> or <code>send()</code>) to hand these bytes to the OS kernel. This is the boundary between user space (browser) and kernel space.</p>
<p>If you&#39;re using HTTPS, the TLS layer encrypts these HTTP bytes before handing them to TCP. From TCP&#39;s perspective, it&#39;s just receiving encrypted bytes it doesn&#39;t know or care that it&#39;s HTTP.</p>
<p>In Node.js, you can see the layers clearly if you open a TCP connection yourself and write the HTTP request as plain text:</p>
<pre><code class="language-js">const net = require('net');

// 1. Open a TCP connection to example.com on port 80
// DNS RESOLUTION happens here:
// - Node calls the OS function getaddrinfo("example.com", "80")
// - getaddrinfo queries DNS servers to resolve "example.com" â†’ IP (e.g., 93.184.216.34)
// - Then the kernel initiates TCP 3-way handshake to that IP
const socket = net.createConnection(80, 'example.com', () => {
  
  // 2. Build a minimal HTTP/1.1 request
  const request = [
    'GET /page.html HTTP/1.1',
    'Host: example.com',
    'User-Agent: demo-client',
    'Connection: close',
    '',
    '' // empty line ends headers
  ].join('\r\n');

  // 3. Send the HTTP request bytes over the TCP stream
  socket.write(request);
});</code></pre><h3>ğŸŸ  2. Transport Layer: TCP Segments</h3>
<p>The kernel&#39;s TCP implementation receives the data bytes from the application via the socket&#39;s send buffer.<br>Unlike the unreliable IP layer below (which can drop, duplicate, or reorder packets), TCP guarantees that, reliability, ordering and integrity.</p>
<p>TCP achieves this by wrapping outgoing bytes with a <strong>TCP header</strong> that contains all the metadata needed to track, verify, and reassemble the byte stream.</p>
<pre><code class="language-schema">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 32 bits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Source Port               â”‚        Destination Port         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           Sequence Number                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        Acknowledgment Number                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Data    â”‚ Rsrv    â”‚Câ”‚Eâ”‚Uâ”‚Aâ”‚Pâ”‚Râ”‚Sâ”‚Fâ”‚           Window Size           â”‚
â”‚Off     â”‚         â”‚Wâ”‚Câ”‚Râ”‚Câ”‚Sâ”‚Sâ”‚Yâ”‚Iâ”‚                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            Checksum              â”‚         Urgent Pointer          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          Options (if any)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                Data                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><strong>Ordering</strong>: The sender assigns a <strong>sequence number</strong> to the bytes it sends so each segment can be placed at the correct position in the byte stream. The receiver buffer and and reorder.</p>
<p><strong>Reliability</strong>: The sender keeps unacknowledged bytes in a send buffer and retransmits when it detects loss (timeouts and other signals). When acknowledgments arrive, the sender can discard the acknowledged bytes from its send buffer.</p>
<p><strong>Integrity</strong>: The sender computes a <strong>checksum</strong> over the segment and includes it in the header so corruption can be detected in transit. Receivers re compute the checksum on their side, compare with the one in header and drop if different.</p>
<p><strong>Other mechanisms:</strong></p>
<ul>
<li><p><strong>Delivery to the right app</strong> â€” <strong>Source/Destination Port</strong>: The sender sets a destination port to target the right service (e.g., 443 for HTTPS) and a source port to identify this connection locally.</p>
</li>
<li><p><strong>Flow control</strong> â€” <strong>Window Size</strong>: The sender respects the advertised window and avoids sending more data than the peer can buffer.</p>
</li>
<li><p><strong>Segmentation</strong> â€” <strong>MSS (Maximum Segment Size)</strong>: Negotiated in <strong>Options</strong> to split the byte stream into segments that fit the network path (typically ~1460 bytes to fit in a 1500-byte Ethernet frame without IP fragmentation).</p>
</li>
<li><p><strong>Connection lifecycle</strong> â€” <strong>Flags</strong> (SYN, ACK, FIN, RST, PSH): Control the state of the connectionâ€”establishing (SYN), acknowledging (ACK), closing (FIN), or aborting (RST).</p>
</li>
</ul>
<h3>ğŸŸ£ 3. Internet Layer: IP Packets</h3>
<p>The IP layer in the kernel receives each transport segment and wraps it in an IP packet. Unlike TCP, IP doesnâ€™t try to make delivery reliable. Instead, it provides <strong>best-effort forwarding</strong> across many networks.</p>
<p><strong>Adding the IP Header</strong>: A 20-byte header (for IPv4) is prepended with:</p>
<pre><code class="language-schema">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€ 32 bits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Version â”‚  IHL  â”‚ DSCP â”‚ ECN   â”‚           Total Length            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Identification         â”‚Flags â”‚       Fragment Offset      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Time To Live     â”‚    Protocol       â”‚  Header Checksum           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         Source IP Address                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                       Destination IP Address                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          Options (if any)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><strong>Routing (sender-side)</strong>: Before sending a packet, the host consults its <strong>routing table</strong>: a small list of â€œif the destination matches this prefix, send it to that next hop via this interfaceâ€. On a typical laptop, most offâ€‘network destinations select the <strong>default route</strong>, which means â€œsend to my gatewayâ€.</p>
<p>Example routing table (simplified):</p>
<pre><code class="language-text">Destination prefix     Next hop        Interface
-------------------    -----------     ---------
192.168.1.0/24         (on-link)        wlan0
10.0.0.0/8             192.168.1.2      wlan0
0.0.0.0/0              192.168.1.1      wlan0   (default route)</code></pre><p>If the destination is <code>93.184.216.34</code>, it doesnâ€™t match the first two entries, so the default route (<code>0.0.0.0/0</code>) is used: send the packet to <code>192.168.1.1</code> (your gateway) on <code>wlan0</code>.</p>
<p>At this point, the sender knows <em>where to send the packet next</em> (next hop + interface). Now it can construct the IP packet that will travel across the network.</p>
<p><strong>MTU and fragmentation</strong>: Links have a maximum size they can carry in one unit (MTU). If a packet is too large for the next hop, the sender can split it into smaller pieces and mark them so they can be stitched back together later, so senders often try to stay below the effective path MTU to avoid fragmentation.</p>
<p><strong>Building the IP packet (sender-side)</strong>: The kernel builds a packet by taking the payload (the transport segment) and prepending an IP header. Concretely, the sender:</p>
<ul>
<li>Set <strong>source</strong> and <strong>destination</strong> IP addresses (found from routing table).</li>
<li>Set a <strong>hop limit (TTL)</strong> to bound how far the packet can travel.</li>
<li>Sets the Protocol field to identify the payload type (for example, TCP), so the receiver knows which transport handler should process it.</li>
<li>Fills in length fields so the receiver can determine the exact packet boundaries.</li>
<li>Set the computed checksum once the header fields are final, so the receiver (and intermediary hop) can verify header integrity.</li>
</ul>
<h3>ğŸŸ¢ 4. Link Layer: Ethernet Frames</h3>
<p>The kernel passes the IP packet to the <strong>network driver</strong> for your NIC (Network Interface Card). The driver needs to wrap it in an Ethernet frame, but first it needs to know the <strong>MAC address</strong> of the next hop.</p>
<p><strong>ARP (Address Resolution Protocol)</strong>: IP addresses work across networks, but on a local network, devices use MAC addresses. If the kernel needs to send a packet to <code>192.168.1.1</code> (your router), it needs that router&#39;s MAC address:</p>
<ol>
<li>Check the <strong>ARP cache</strong> for a recent mapping</li>
<li>If not found, broadcast an ARP request: &quot;Who has <code>192.168.1.1</code>?&quot;</li>
<li>Wait for the ARP reply containing the MAC address (e.g., <code>11:22:33:44:55:66</code>)</li>
<li>Cache this mapping for future use</li>
</ol>
<p><strong>Building the Ethernet Frame</strong>: The driver adds a 14-byte Ethernet header:</p>
<ul>
<li>Destination MAC address: the next hop (router or local peer)</li>
<li>Source MAC address: your NIC&#39;s hardware address</li>
<li>EtherType: <code>0x0800</code> for IPv4, <code>0x86DD</code> for IPv6</li>
</ul>
<p>It also appends a 4-byte <strong>Frame Check Sequence (FCS)</strong> at the end a CRC checksum computed over the frame.</p>
<p><strong>The Send Queue</strong>: The driver places the frame in the NIC&#39;s <strong>transmit queue</strong> (a ring buffer in memory). The NIC reads frames from this queue using <strong>DMA (Direct Memory Access)</strong>, copying them directly without involving the CPU.</p>
<h3>âšª 5. Physical Layer: Signals</h3>
<p>The NIC hardware takes each frame and converts the digital bits into physical signals:</p>
<ul>
<li><strong>Ethernet (wired)</strong>: Bits become electrical voltage pulses traveling through copper cables</li>
<li><strong>Fiber optic</strong>: Bits become light pulses traveling through glass fiber</li>
<li><strong>Wi-Fi</strong>: Bits become radio waves transmitted through the air (2.4 GHz or 5 GHz)</li>
</ul>
<p>Once transmitted, these signals leave your machine and enter the network medium (wire, fiber, or air). From there, the network can carry them onward toward the destination.</p>
<h2 class="title">Decapsulation: How Data Moves Up the Stack</h2>
<p>On the way back, everything happens in reverse: each layer <strong>unwraps</strong> its header, checks its own addressing, and passes the rest upward.</p>
<h3>âšª 1. Physical Layer: Receiving Signals</h3>
<p>The <strong>NIC hardware</strong> receives signals and decodes them:</p>
<ul>
<li>Receives raw electrical/radio/optical signals from the wire or air</li>
<li>Decodes signals into bits</li>
<li>Reconstructs the digital frame</li>
</ul>
<h3>ğŸŸ¢ 2. Link Layer: Filtering Frames</h3>
<p>The <strong>NIC</strong> and <strong>driver</strong> filter and process frames:</p>
<ul>
<li>Checks the <strong>destination MAC address</strong>:<ul>
<li>If it doesn&#39;t match this NIC (and not broadcast/multicast) â†’ drop</li>
<li>If it matches â†’ continue</li>
</ul>
</li>
<li>Reads the <strong>EtherType</strong> field to determine upper protocol (IPv4, IPv6, ARP, etc.)</li>
<li>Verifies frame checksum (discard corrupted frames)</li>
<li>Hands valid frames to the <strong>kernel</strong> via DMA</li>
</ul>
<h3>ğŸŸ£ 3. Internet Layer: Routing to Host</h3>
<p>In the kernel, the <strong>IP layer</strong> processes packets:</p>
<ul>
<li>Parses the <strong>IP header</strong></li>
<li>Verifies the destination <strong>IP address</strong> (is this packet for us?)</li>
<li>Checks the <strong>protocol field</strong> (6 = TCP, 17 = UDP, 1 = ICMP, etc.)</li>
<li>Strips the IP header and passes payload to the correct transport protocol<ul>
<li>If this machine is acting as a router, it may also decrement the hop limit (TTL) and either forward the packet onward or drop it if the hop limit reaches zero.</li>
<li>If the packet arrived as fragments, the receiver reassembles them (or drops incomplete ones) before handing the payload up.</li>
</ul>
</li>
</ul>
<h3>ğŸŸ  4. Transport Layer: Delivering to Application</h3>
<p>The <strong>TCP implementation in the kernel</strong> processes segments:</p>
<ul>
<li><p>Parses the <strong>TCP header</strong>:</p>
<ul>
<li>source port / destination port</li>
<li>sequence / acknowledgement numbers</li>
<li>flags (SYN, ACK, FIN, etc.)</li>
<li>Verifies integrity (e.g., checksum) and discards corrupted segments</li>
</ul>
</li>
<li><p>Reorders segments, removes duplicates, and acknowledges received data so the sender can advance its send window</p>
</li>
<li><p>Finds the correct <strong>socket</strong> using the 4â€‘tuple: <code>(source IP, source port, dest IP, dest port)</code></p>
</li>
<li><p>Exposes a clean <strong>byte stream</strong> to the application (via <code>read</code>/<code>recv</code>)</p>
</li>
</ul>
<h3>ğŸ”µ 5. Application Layer: Parsing HTTP</h3>
<p>Finally, the <strong>browser process</strong> reads from the socket:</p>
<ul>
<li>Receives the HTTP response bytes: <code>HTTP/1.1 200 OK</code>, headers, and body</li>
<li>Parses the status line and headers</li>
<li>Uses headers (<code>Content-Type</code>, <code>Content-Length</code>, <code>Transfer-Encoding</code>) to decode the body</li>
<li>Hands the body to the renderer to parse HTML, CSS, images, etc.</li>
</ul>

      <p>
        <em>Published: December 1, 2025</em>
      </p>
    </main>
  </body>
</html>

