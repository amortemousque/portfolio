<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="description" content="Explore how browsers download web pages through the TCP/IP stack. Learn about encapsulation, decapsulation, and how data moves from HTTP requests down to physical bits and back up to the browser." />
    <meta name="keywords" content="Portfolio, Engineer, Web, Browser, TCP/IP, HTTP, Networking, Protocol Stack, Encapsulation" />
    <meta property="og:url" content="https://mortemousque.com/posts/browser-download-page" />
    <meta property="og:description" content="Explore how browsers download web pages through the TCP/IP stack. Learn about encapsulation, decapsulation, and how data moves from HTTP requests down to physical bits and back up to the browser." />
    <meta property="og:title" content="Browser Downloading Web Pages - Aymeric Mortemousque" />
    <meta property="og:type" content="article" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/assets/style.css" />
    <link href="https://fonts.googleapis.com/css?family=Chivo:400,700|Playfair+Display:400,700&display=swap" rel="stylesheet" />
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/highlight.min.js"></script>
    <!-- Mermaid for diagrams rendered from ```mermaid code blocks -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>
      if (window.mermaid) {
        window.mermaid.initialize({ startOnLoad: true });
      }
    </script>
    <title>Browser Downloading Web Pages</title>
    <script type="module" src="/assets/scripts/components/index.js"></script>
  </head>

  <body class="post">
    <site-header variant="post-detail" title="Browser Downloading Web Pages" back-url="/posts"></site-header>
    <main>
      <p>When you type a URL and hit Enter, your browser kicks off a surprisingly complex journey across the network. Under the hood, your HTTP request is wrapped, sliced, addressed, and turned into raw bits that travel through the TCP/IP stack, cables, routers, and Wiâ€‘Fi. In this post, weâ€™ll walk through how a browser actually downloads a web page, from your address bar down to the wire and back up.</p>
<h2 class="title">From URL Input to Network Request</h2>
<p>When the user enters a URL, the browser process handles it on the UI<br>thread. It parses the text to decide what to do:</p>
<ul>
<li>If the input looks like a search term â†’ send it to the search engine.</li>
<li>If it looks like a valid URL â†’ forward it to the networking service (another process).</li>
</ul>
<p>The networking service starts the request using the TCP/IP stack.<br>A network connection commonly use 3 application layer protocol (DNS, TLS, HTTP), each relaying on TCP/IP stack.</p>
<p>in js we have a high level abasctraciton <code>fetch</code> API hiding the complexity. but under the hood there are multiple phase for a request.<br>but lets look at a lowev level python implementation:</p>
<pre><code class="language-py">import socket
import ssl

# --------------------------
# 1. CREATE SOCKET (no TCP yet)
# --------------------------
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# --------------------------
# 2. WRAP IN TLS (optional for HTTPS)
# --------------------------
context = ssl.create_default_context()
conn = context.wrap_socket(sock, server_hostname="example.com")

# --------------------------
# 3. CONNECT (DNS lookup + TCP handshake happens here)
# --------------------------
conn.connect(("example.com", 443))

# --------------------------
# 4. BUILD HTTP REQUEST BY HAND
# --------------------------
http_request = (
    "POST /api/items HTTP/1.1\r\n"
    "Host: example.com\r\n"
    "Content-Type: application/json\r\n"
    "Content-Length: 14\r\n"
    "\r\n"
    '{"name":"foo"}'
)

# --------------------------
# 5. SEND HTTP PAYLOAD (headers + body)
# --------------------------
conn.sendall(http_request.encode())

# --------------------------
# 6. RECEIVE HTTP RESPONSE
# --------------------------
response = conn.recv(4096)
print(response.decode())

conn.close()</code></pre><p>Now lets see each phase in depth</p>
<h2 class="title">Establishing the Connection: DNS, TCP, and TLS</h2>
<p>Before your browser can send the HTTP request, it needs to establish a connection to the server. This happens in three steps:</p>
<h3>1. DNS Lookup: From Domain to IP Address</h3>
<p>Your browser needs an IP address to connect, but you typed <code>https://example.com</code>, so the browser (or OS) queries DNS servers to resolve the domain name.</p>
<p>If we take the example earlier,  under the hood <code>conn.connect((&quot;example.com&quot;, 443))</code> triggers the OS to call <code>getaddrinfo()</code> internally, which performs DNS resolution.</p>
<p><strong>DNS Records:</strong></p>
<p>First, it&#39;s important to understand how DNS servers store and organize domain information. DNS uses different <strong>record types</strong> stored in <strong>zone files</strong> to map domain names to various resources. Each record type serves a specific purpose, whether it&#39;s pointing to an IP address, defining an alias, or specifying authoritative name servers.</p>
<p>Here is a simplified version of a zone file for example.com</p>
<pre><code class="language-text">DNS Zone File: example.com
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NAME                 â”‚ TTL  â”‚ TYPE  â”‚ DATA                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ example.com.         â”‚ 3600 â”‚ A     â”‚ 93.184.216.34                    â”‚
â”‚ example.com.         â”‚ 3600 â”‚ AAAA  â”‚ 2606:2800:220:1:248:1893:25c8... â”‚
â”‚ www.example.com.     â”‚ 3600 â”‚ CNAME â”‚ example.com.                     â”‚
â”‚ example.com.         â”‚ 3600 â”‚ NS    â”‚ ns1.example.com.                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><strong>How they work:</strong></p>
<ul>
<li><strong>A Record</strong>: Domain â†’ IPv4 address. Browser queries for an A record to get the server IP.</li>
<li><strong>AAAA Record</strong>: Domain â†’ IPv6 address. Same as A but for the newer IPv6 protocol.</li>
<li><strong>CNAME Record</strong>: Domain alias â†’ another domain. DNS follows the chain: <code>www.example.com</code> â†’ <code>example.com</code> â†’ <code>93.184.216.34</code></li>
<li><strong>NS Record</strong>: Tells which servers are authoritative for this domain (handle DNS queries for it).</li>
</ul>
<p><strong>DNS Resolution Flow:</strong></p>
<p>DNS resolution checks caches at every level (browser, OS, resolver). On cache miss, it follows a hierarchical lookup: browser â†’ local DNS resolver â†’ root server â†’ TLD server â†’ authoritative server.</p>
<pre class="mermaid">flowchart LR
    Browser["ğŸ–¥ï¸ Browser<br/>example.com<br/><i>(cache miss)</i>"]
    
    subgraph LocalDNS["Local DNS Resolver<br/>(ISP or 8.8.8.8)"]
        direction TB
        Resolver["DNS Resolver<br/>Recursive Lookup"]
    end
    
    subgraph DNSHierarchy["DNS Server Hierarchy"]
        direction TB
        Root["ğŸŒ Root Server<br/>(.)"]
        TLD["ğŸŒ TLD Server<br/>(.com)"]
        Auth["ğŸŒ Authoritative Server<br/>(example.com)"]
    end
    
    Browser -.->|"1. Query: example.com<br/>(after browser/OS cache miss)"| Resolver
    Resolver -->|"2. Where is .com?"| Root
    Root -->|"3. NS record for .com<br/>â†’ TLD server IP"| Resolver
    Resolver -->|"4. Where is example.com?"| TLD
    TLD -->|"5. NS record for example.com<br/>â†’ Auth server IP"| Resolver
    Resolver -->|"6. A record for example.com?"| Auth
    Auth -->|"7. A record: 93.184.216.34<br/>TTL: 3600s"| Resolver
    Resolver -->|"8. IP: 93.184.216.34<br/>(cached at all levels)"| Browser
    
    style LocalDNS fill:#fff4e1,stroke:#cc8800,stroke-width:2px
    style DNSHierarchy fill:#ffe1f5,stroke:#cc0066,stroke-width:2px
    style Browser fill:#b3d9ff,stroke:#0066cc
    style Resolver fill:#ffe6b3,stroke:#cc8800
    style Root fill:#ffb3d9,stroke:#cc0066
    style TLD fill:#ffcce6,stroke:#cc0066
    style Auth fill:#ffe6f5,stroke:#cc0066</pre><h3>2. TCP Handshake: Opening the Connection</h3>
<p>Now that we have the serverâ€™s IP address, the OS kernel opens a TCP connection by performing the 3-way handshake. Each step is a TCP segment whose header includes control-flag bits (such as SYN and ACK) that are set to 0 or 1.</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: TCP 3-Way Handshake (Connection Establishment)
    Client->>Server: SYN (seq=100)
    Server->>Client: SYN-ACK (seq=300, ack=101)
    Client->>Server: ACK (seq=101, ack=301)
    Note over Client,Server: Connection Established âœ“
</pre><ol>
<li><strong>SYN</strong>: Your machine sends a TCP segment with the SYN flag to the server&#39;s IP and port (e.g., port 443 for HTTPS)</li>
<li><strong>SYN-ACK</strong>: The server responds with SYN and ACK flags, acknowledging your request</li>
<li><strong>ACK</strong>: Your machine sends back an ACK to confirm the connection is open</li>
</ol>
<h3>3. TLS Negotiation: Securing the Connection</h3>
<p>The TLS is the protocol of encryption of HTTP*<strong>S</strong>. Encrypted data<br>For HTTPS, the browser and server must negotiate encryption <strong>before</strong> sending any HTTP data. This happens in the TLS handshake:</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: TLS Handshake (Establishing Encryption)
    Client->>Server: ClientHello<br/>(TLS versions, cipher suites, random)
    Server->>Client: ServerHello<br/>(chosen cipher, random)
    Server->>Client: Certificate<br/>(public key, signed by CA)
    Server->>Client: ServerHelloDone
    
    Note over Client: Verify certificate<br/>against trusted CAs
    
    Client->>Server: ClientKeyExchange<br/>(encrypted pre-master secret)
    Client->>Server: ChangeCipherSpec
    Client->>Server: Finished (encrypted)
    
    Note over Server: Derive session keys<br/>from randoms + pre-master
    
    Server->>Client: ChangeCipherSpec
    Server->>Client: Finished (encrypted)
    
    Note over Client,Server: Secure Connection Established âœ“<br/>All HTTP traffic now encrypted</pre><p><strong>Understanding the TLS Handshake:</strong></p>
<ol>
<li><p><strong>ClientHello</strong>: Browser announces supported TLS versions, cipher suites, and sends a random value</p>
</li>
<li><p><strong>ServerHello + Certificate</strong>: Server picks a TLS version and cipher suite, sends its certificate (with public key) and another random value</p>
</li>
<li><p><strong>Certificate Verification</strong>: Browser validates the server&#39;s certificate against trusted Certificate Authorities (CAs)</p>
</li>
<li><p><strong>Key Exchange</strong>: Client generates a pre-master secret, encrypts it with the server&#39;s public key, and sends it. Both sides derive shared session keys using the random values and pre-master secret</p>
</li>
<li><p><strong>Finished</strong>: Both sides send encrypted &quot;Finished&quot; messages to confirm the handshake succeeded and verify the keys work</p>
</li>
</ol>
<p>Now every HTTP message will be encrypted with the negotiated keys before being handed to TCP.</p>
<h2 class="title">TCP/IP Model Overview</h2>
<p>Web communication uses a stack of protocols. <strong>DNS and TLS are an application-layer protocol</strong> (like HTTP). Whatever the protocol, its messages still make a round trip â€œon the wireâ€ by being <strong>encapsulated</strong> inside the lower layers (TCP/UDP â†’ IP â†’ link â†’ physical). Each layer builds on top of the one below it, from your browser down to the physical wire.</p>
<pre><code class="language-text">HTTPS request (bytes carried inside one Ethernet frame):

â”‚ Ethernet Header â”‚ IPv4 Header â”‚ TCP Header â”‚ TLS Record Header â”‚ HTTP bytes â”‚ FCS 
â”‚     ~14 B       â”‚  20â€“60 B    â”‚  20â€“60 B   â”‚       5 B         â”‚ variable   â”‚ 4 B 
</code></pre><ol>
<li><p><strong>Application Layer</strong> is where your browser lives. It speaks protocols like HTTP, HTTPS, and TLS.</p>
</li>
<li><p><strong>Transport Layer</strong> runs in your OS kernel. It uses TCP or UDP to break data into <strong>segments</strong>. It ensures <strong>reliability and ordering</strong>: lost segments are <strong>retransmitted</strong>, and out-of-order segments are <strong>reassembled</strong> before being delivered to the application.</p>
</li>
<li><p><strong>Internet Layer</strong>, also in the kernel, wraps those segments into <strong>packets</strong> using IP (IPv4 or IPv6), adding source and destination IP addresses so they can be routed across networks.</p>
</li>
<li><p><strong>Link Layer</strong> is handled by your network driver and NIC (Network Interface Card). It frames IP packets into <strong>frames</strong> for the local network (Ethernet/Wiâ€‘Fi), using <strong>MAC addresses</strong> to deliver the data to the <strong>next hop</strong> (either the destination host on the same LAN, or your default gateway/router).</p>
</li>
<li><p><strong>Physical Layer</strong> is pure hardware, your NIC converts those frames into actual <strong>bits</strong>: electrical signals over copper, light pulses through fiber, or radio waves through the air.</p>
</li>
</ol>
<h3>Generic principle (true for every layer)</h3>
<p>Each layer processes a stream of <strong>bytes</strong> and understands only <strong>its own header bytes</strong>. Everything after that header is the layer&#39;s <strong>payload</strong> (opaque bytes as far as that layer is concerned). The payload may <em>represent</em> structured data for the next layer up, but this layer doesn&#39;t need to interpret it.</p>
<pre><code class="language-">Layer N:  [ My Header | Payload (opaque bytes) ]
                       â””â”€ Next layer's data â”€â”˜</code></pre><p>The header exists so each layer can do its job: the sender sets it during <strong>encapsulation</strong>, and the receiver reads it during <strong>decapsulation</strong> to decide <strong>who should handle the payload next</strong>. Headers typically include:</p>
<pre><code class="language-">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Header                      â”‚   Payload   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚ Size/Length    â”‚ Payload Type â”‚ Address  â”‚             â”‚
â”‚ (boundaries)   â”‚ (next parser)â”‚ (routing)â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><ul>
<li><strong>Header size / boundaries</strong>: either a fixed header size (e.g., Ethernet without VLAN) or a field that says how long the header is (e.g., IPv4 IHL, TCP Data Offset), plus sometimes a <strong>total length</strong> (e.g., IPv4 Total Length) so you know where the packet ends.</li>
<li><strong>Encapsulated payload type (in this header)</strong>: a field in the current layer&#39;s header that tells what kind of payload is inside, so the receiver can pick the right parser (e.g., Ethernet <strong>EtherType</strong> â†’ IPv4/IPv6, IPv4 <strong>Protocol</strong> / IPv6 <strong>Next Header</strong> â†’ TCP/UDP/ICMP).</li>
<li><strong>Routing / delivery addresses</strong>: the bytes used for forwarding and demultiplexing (MAC for the local hop, IP for end-to-end routing, ports for delivery to a process).</li>
</ul>
<h2 class="title">Encapsulation: How Data Moves Down the Stack</h2>
<p>Let&#39;s follow a single HTTP request as it travels from your browser down to the wire.</p>
<pre class="mermaid">flowchart LR
    subgraph L1["Application Layer - Data"]
        A["GET /page.html HTTP/1.1<br/>Host: example.com<br/>..."]
    end
    
    subgraph L2["Transport Layer - Segment"]
        direction LR
        B1["TCP Header<br/>â”â”â”â”â”â”â”â”<br/>Src Port: 54321<br/>Dst Port: 443<br/>Seq, Ack<br/>Flags"]
        B2["HTTP Data"]
    end
    
    subgraph L3["Internet Layer - Packet"]
        direction LR
        C1["IP Header<br/>â”â”â”â”â”â”â”<br/>Src IP: 192.168.1.5<br/>Dst IP: 93.184.216.34<br/>Protocol: TCP<br/>TTL: 64"]
        C2["TCP Header"]
        C3["HTTP Data"]
    end
    
    subgraph L4["Link Layer - Frame"]
        direction LR
        D1["MAC Header<br/>â”â”â”â”â”â”â”â”<br/>Src MAC: aa:bb:cc:...<br/>Dst MAC: 11:22:33:...<br/>EtherType: IPv4"]
        D2["IP Header"]
        D3["TCP Header"]
        D4["HTTP Data"]
    end
    
    subgraph L5["Physical Layer - Bits"]
        direction LR
        E["01010110 01101001 00110100..."]
    end
    
    L1 -.-> L2
    L2 -.-> L3
    L3 -.-> L4
    L4 -.-> L5
    
    style L1 fill:#e1f5ff,stroke:#0066cc
    style L2 fill:#fff4e1,stroke:#cc8800
    style L3 fill:#ffe1f5,stroke:#cc0066
    style L4 fill:#e1ffe8,stroke:#00cc66
    style L5 fill:#f5f5f5,stroke:#666666
    
    style A fill:#e1f5ff
    style B1 fill:#fff4e1
    style B2 fill:#e1f5ff
    style C1 fill:#ffe1f5
    style C2 fill:#fff4e1
    style C3 fill:#e1f5ff
    style D1 fill:#e1ffe8
    style D2 fill:#ffe1f5
    style D3 fill:#fff4e1
    style D4 fill:#e1f5ff
    style E fill:#f5f5f5</pre><hr>
<h3>ğŸ”µ 1. Application Layer: HTTP Message</h3>
<p>The browser builds an HTTP request as plain text. For <code>https://example.com/page.html</code>, it creates:</p>
<pre><code class="language-http">GET /page.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml...
Connection: keep-alive
</code></pre><p>The browser then calls a <strong>system call</strong> (like <code>write()</code> or <code>send()</code>) to hand these bytes to the OS kernel. This is the boundary between user space (browser) and kernel space.</p>
<p>If you&#39;re using HTTPS, the TLS layer encrypts these HTTP bytes before handing them to TCP. From TCP&#39;s perspective, it&#39;s just receiving encrypted bytesâ€”it doesn&#39;t know or care that it&#39;s HTTP.</p>
<p>In Node.js, you can see the layers clearly if you open a TCP connection yourself and write the HTTP request as plain text:</p>
<pre><code class="language-js">const net = require('net');

// 1. Open a TCP connection to example.com on port 80
// DNS RESOLUTION happens here:
// - Node calls the OS function getaddrinfo("example.com", "80")
// - getaddrinfo queries DNS servers to resolve "example.com" â†’ IP (e.g., 93.184.216.34)
// - Then the kernel initiates TCP 3-way handshake to that IP
const socket = net.createConnection(80, 'example.com', () => {
  
  // 2. Build a minimal HTTP/1.1 request
  const request = [
    'GET /page.html HTTP/1.1',
    'Host: example.com',
    'User-Agent: demo-client',
    'Connection: close',
    '',
    '' // empty line ends headers
  ].join('\r\n');

  // 3. Send the HTTP request bytes over the TCP stream
  socket.write(request);
});

// 4. Read the HTTP response bytes from the TCP stream
socket.on('data', chunk => {
  process.stdout.write(chunk.toString());
});

socket.on('end', () => {
  console.log('\n--- connection closed ---');
});</code></pre><h3>ğŸŸ  2. Transport Layer: TCP Segments</h3>
<p>The kernel&#39;s TCP implementation receives the data bytes from the application via the socket&#39;s send buffer.</p>
<p><strong>TCP&#39;s promise: reliable, ordered, and error-checked delivery of bytes.</strong></p>
<p>Unlike the unreliable IP layer below (which can drop, duplicate, or reorder packets), TCP guarantees that:</p>
<ul>
<li>Every byte arrives <strong>exactly once</strong> (reliability)</li>
<li>Bytes arrive in the <strong>same order</strong> they were sent (ordering)  </li>
<li>Corrupted bytes are <strong>detected and discarded</strong> (integrity)</li>
</ul>
<p>TCP achieves this by wrapping outgoing bytes with a <strong>TCP header</strong> that contains all the metadata needed to track, verify, and reassemble the byte stream.</p>
<pre><code class="language-schema">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 32 bits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Source Port               â”‚        Destination Port         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           Sequence Number                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        Acknowledgment Number                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Data    â”‚ Rsrv    â”‚Câ”‚Eâ”‚Uâ”‚Aâ”‚Pâ”‚Râ”‚Sâ”‚Fâ”‚           Window Size           â”‚
â”‚Off     â”‚         â”‚Wâ”‚Câ”‚Râ”‚Câ”‚Sâ”‚Sâ”‚Yâ”‚Iâ”‚                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            Checksum              â”‚         Urgent Pointer          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          Options (if any)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                Data                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><strong>Ordering</strong> â€” Reassembling the byte stream in the correct sequence:</p>
<ul>
<li><strong>Sequence Number</strong>: Every segment&#39;s data is numbered, marking where it belongs in the stream. If segment #100 arrives before segment #50, TCP buffers #100 and waits for #50, delivering them to the application in order.</li>
</ul>
<p><strong>Reliability</strong> â€” Ensuring every byte arrives exactly once:</p>
<ul>
<li><strong>Acknowledgment Number</strong>: The receiver tells the sender which bytes it has successfully received. If the sender doesn&#39;t get an ACK within a timeout (or sees duplicate ACKs), it knows the segment was lost and <strong>retransmits</strong> it.</li>
<li>TCP keeps copies of sent segments in a send buffer until they&#39;re acknowledged, then discards them.</li>
</ul>
<p><strong>Error-checking</strong> â€” Detecting corrupted data:</p>
<ul>
<li><strong>Checksum</strong>: Covers both header and data. If the receiver detects corruption, it silently drops the segment. The sender&#39;s timeout will trigger retransmission of clean data.</li>
</ul>
<p><strong>Supporting mechanisms:</strong></p>
<ul>
<li><p><strong>Delivery to the right app</strong> â€” <strong>Source/Destination Port</strong>: Together with IP addresses, these identify which socket/process should receive the data (e.g., port 443 for HTTPS).</p>
</li>
<li><p><strong>Flow control</strong> â€” <strong>Window Size</strong>: The receiver advertises how much buffer space it has. The sender won&#39;t send more data than the receiver can handle, preventing buffer overflow.</p>
</li>
<li><p><strong>Segmentation</strong> â€” <strong>MSS (Maximum Segment Size)</strong>: Negotiated in <strong>Options</strong> to split the byte stream into segments that fit the network path (typically ~1460 bytes to fit in a 1500-byte Ethernet frame without IP fragmentation).</p>
</li>
<li><p><strong>Connection lifecycle</strong> â€” <strong>Flags</strong> (SYN, ACK, FIN, RST, PSH): Control the state of the connectionâ€”establishing (SYN), acknowledging (ACK), closing (FIN), or aborting (RST).</p>
</li>
<li><p><strong>Header length</strong> â€” <strong>Data Offset</strong>: Since TCP options are variable, this field tells the receiver where the header ends and data begins.</p>
</li>
</ul>
<h3>ğŸŸ£ 3. Internet Layer: IP Packets</h3>
<p>The IP layer in the kernel receives each TCP segment and wraps it in an IP packet. This is where <strong>routing</strong> happensâ€”deciding where to send this packet next.</p>
<p><strong>Adding the IP Header</strong>: A 20-byte header (for IPv4) is prepended with:</p>
<pre><code class="language-schema">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€ 32 bits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Version â”‚  IHL  â”‚ DSCP â”‚ ECN   â”‚           Total Length            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Identification         â”‚Flags â”‚       Fragment Offset      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Time To Live     â”‚    Protocol       â”‚  Header Checksum           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         Source IP Address                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                       Destination IP Address                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          Options (if any)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><ul>
<li>Source IP address: your machine (e.g., <code>192.168.1.5</code>)</li>
<li>Destination IP address: the server (e.g., <code>93.184.216.34</code>)</li>
<li>Protocol field: set to <code>6</code> for TCP (tells the receiver what&#39;s inside)</li>
<li>TTL (Time To Live): starts at 64 or 128, decremented at each router hop to prevent infinite loops</li>
<li>Header checksum: for error detection</li>
<li>Total length: size of the entire packet (header + TCP segment)</li>
</ul>
<p><strong>Routing Decision</strong>: The kernel looks up the destination IP in its <strong>routing table</strong>:</p>
<ul>
<li>Is it on the local network? Send directly to that host</li>
<li>Otherwise, send to the default gateway (your router)</li>
</ul>
<p>The routing table tells IP which <strong>network interface</strong> to use (Wi-Fi, Ethernet, VPN) and what the <strong>next hop</strong> should be.</p>
<p><strong>MTU and Fragmentation</strong>: If the packet is larger than the network&#39;s MTU (Maximum Transmission Unit) (typically 1500 bytes for Ethernet), IP might fragment it into smaller packets. However, modern TCP uses Path MTU Discovery to avoid thisâ€”it discovers the smallest MTU along the path and tells TCP to use a smaller MSS.</p>
<h3>ğŸŸ¢ 4. Link Layer: Ethernet Frames</h3>
<p>The kernel passes the IP packet to the <strong>network driver</strong> for your NIC (Network Interface Card). The driver needs to wrap it in an Ethernet frame, but first it needs to know the <strong>MAC address</strong> of the next hop.</p>
<p><strong>ARP (Address Resolution Protocol)</strong>: IP addresses work across networks, but on a local network, devices use MAC addresses. If the kernel needs to send a packet to <code>192.168.1.1</code> (your router), it needs that router&#39;s MAC address:</p>
<ol>
<li>Check the <strong>ARP cache</strong> for a recent mapping</li>
<li>If not found, broadcast an ARP request: &quot;Who has <code>192.168.1.1</code>?&quot;</li>
<li>The router responds: &quot;I have <code>192.168.1.1</code>, my MAC is <code>11:22:33:44:55:66</code>&quot;</li>
<li>Cache this mapping for future use</li>
</ol>
<p><strong>Building the Ethernet Frame</strong>: The driver adds a 14-byte Ethernet header:</p>
<ul>
<li>Destination MAC address: the next hop (router or local peer)</li>
<li>Source MAC address: your NIC&#39;s hardware address</li>
<li>EtherType: <code>0x0800</code> for IPv4, <code>0x86DD</code> for IPv6</li>
</ul>
<p>It also adds a 4-byte <strong>Frame Check Sequence (FCS)</strong> at the endâ€”a CRC checksum that lets the receiver detect corrupted frames.</p>
<p><strong>The Send Queue</strong>: The driver places the frame in the NIC&#39;s <strong>transmit queue</strong> (a ring buffer in memory). The NIC reads frames from this queue using <strong>DMA (Direct Memory Access)</strong>â€”copying them directly without involving the CPU.</p>
<h3>âšª 5. Physical Layer: Signals</h3>
<p>The NIC hardware takes each frame and converts the digital bits into physical signals:</p>
<ul>
<li><strong>Ethernet (wired)</strong>: Bits become electrical voltage pulses traveling through copper cables</li>
<li><strong>Fiber optic</strong>: Bits become light pulses traveling through glass fiber</li>
<li><strong>Wi-Fi</strong>: Bits become radio waves transmitted through the air (2.4 GHz or 5 GHz)</li>
</ul>
<p>Once transmitted, these signals carry your HTTP request to the router, then through a chain of routers across the internet, until they reach the destination server&#39;s NICâ€”where the entire process happens in reverse.</p>
<h2 class="title">Decapsulation: How Data Moves Up the Stack</h2>
<p>On the way back, everything happens in reverse: each layer <strong>unwraps</strong> its header, checks its own addressing, and passes the rest upward.</p>
<pre class="mermaid">flowchart LR
    subgraph L5["Physical Layer - Bits"]
        direction LR
        E["01010110 01101001 00110100..."]
    end
    
    subgraph L4["Link Layer - Frame"]
        direction LR
        D1["MAC Header"]
        D2["IP Header"]
        D3["TCP Header"]
        D4["HTTP Data"]
    end
    
    subgraph L3["Internet Layer - Packet"]
        direction LR
        C1["IP Header"]
        C2["TCP Header"]
        C3["HTTP Data"]
    end
    
    subgraph L2["Transport Layer - Segment"]
        direction LR
        B1["TCP Header"]
        B2["HTTP Data"]
    end
    
    subgraph L1["Application Layer - Data"]
        A["HTTP/1.1 200 OK<br/>Content-Type: text/html<br/>..."]
    end
    
    L5 -.-> L4
    L4 -.-> L3
    L3 -.-> L2
    L2 -.-> L1
    
    style L5 fill:#f5f5f5,stroke:#666666
    style L4 fill:#e1ffe8,stroke:#00cc66
    style L3 fill:#ffe1f5,stroke:#cc0066
    style L2 fill:#fff4e1,stroke:#cc8800
    style L1 fill:#e1f5ff,stroke:#0066cc
    
    style E fill:#f5f5f5
    style D1 fill:#e1ffe8
    style D2 fill:#ffe1f5
    style D3 fill:#fff4e1
    style D4 fill:#e1f5ff
    style C1 fill:#ffe1f5
    style C2 fill:#fff4e1
    style C3 fill:#e1f5ff
    style B1 fill:#fff4e1
    style B2 fill:#e1f5ff
    style A fill:#e1f5ff</pre><h3>âšª 1. Physical Layer: Receiving Signals</h3>
<p>The <strong>NIC hardware</strong> receives signals and decodes them:</p>
<ul>
<li>Receives raw electrical/radio/optical signals from the wire or air</li>
<li>Decodes signals into bits</li>
<li>Reconstructs the digital frame</li>
</ul>
<h3>ğŸŸ¢ 2. Link Layer: Filtering Frames</h3>
<p>The <strong>NIC</strong> and <strong>driver</strong> filter and process frames:</p>
<ul>
<li>Checks the <strong>destination MAC address</strong>:<ul>
<li>If it doesn&#39;t match this NIC (and not broadcast/multicast) â†’ drop</li>
<li>If it matches â†’ continue</li>
</ul>
</li>
<li>Reads the <strong>EtherType</strong> field to determine upper protocol (IPv4, IPv6, ARP, etc.)</li>
<li>Verifies frame checksum (discard corrupted frames)</li>
<li>Hands valid frames to the <strong>kernel</strong> via DMA</li>
</ul>
<h3>ğŸŸ£ 3. Internet Layer: Routing to Host</h3>
<p>In the kernel, the <strong>IP layer</strong> processes packets:</p>
<ul>
<li>Parses the <strong>IP header</strong></li>
<li>Verifies the destination <strong>IP address</strong> (is this packet for us?)</li>
<li>Checks the <strong>protocol field</strong> (6 = TCP, 17 = UDP, 1 = ICMP, etc.)</li>
<li>Strips the IP header and passes payload to the correct transport protocol</li>
</ul>
<h3>ğŸŸ  4. Transport Layer: Delivering to Application</h3>
<p>The <strong>TCP implementation in the kernel</strong> processes segments:</p>
<ul>
<li>Parses the <strong>TCP header</strong>:<ul>
<li>source port / destination port</li>
<li>sequence / acknowledgement numbers</li>
<li>flags (SYN, ACK, FIN, etc.)</li>
</ul>
</li>
<li>Finds the correct <strong>socket</strong> using the 4â€‘tuple: <code>(source IP, source port, dest IP, dest port)</code></li>
<li>Reorders segments, handles retransmissions, removes duplicates</li>
<li>Exposes a clean <strong>byte stream</strong> to the application (via <code>read</code>/<code>recv</code>)</li>
</ul>
<h3>ğŸ”µ 5. Application Layer: Parsing HTTP</h3>
<p>Finally, the <strong>browser process</strong> reads from the socket:</p>
<ul>
<li>Receives the HTTP response bytes: <code>HTTP/1.1 200 OK</code>, headers, and body</li>
<li>Parses the status line and headers</li>
<li>Uses headers (<code>Content-Type</code>, <code>Content-Length</code>, <code>Transfer-Encoding</code>) to decode the body</li>
<li>Hands the body to the renderer to parse HTML, CSS, images, etc.</li>
</ul>

      <p>
        <em>Published: December 1, 2025</em>
      </p>
    </main>
  </body>
</html>

